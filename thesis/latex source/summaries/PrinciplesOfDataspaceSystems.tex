\section{Principles of Dataspace Systems}

The document ``Principles of Dataspace System'' of Alon Haley, Michael Franklin and David Meier\cite{Halevy:2006:PDS:1142351.1142352} is based on their previous work ``From Databases to Dataspaces - A New Abstraction for Information Management''\cite{Franklin:2005:DDN:1107499.1107502} where the concept of dataspaces was firstly presented, and poses specific technical challenges realizing Dataspace Support Platforms (DSSPs) relating to query answering, introspection and the benefits of human attention for improving semantic relationships within a dataspace.  
In the following are stated the results of the above mentioned challenges:

\textbf{\begin{large}
1. Query answering
\end{large}}

Queries are posed in a wide range of different languages. Most of the activities will properly begin with a keyword search, but it will also be common to see queries as a result of a form (which results to queries with several selectable predicates). It will come to more complex queries when a user interacts deeper with a certain data source. If it isn't explicitly stated, it it usual, that a user is likely to believe that a query considers all relevant data in a dataspace, regardless of the used data model or schema. Even if a query is posed to a data source, it is implicitly expected that the system considers the data of other sources, as well. If additional answers are desired, one has to do transformations on the schema and the data model.

\textbf{1.1.Challenges of answer querying}

Answers corresponded to queries of a dataspace are different from traditional queries in several ways. The challenges to it are analyzed more deeply in the third chapter:

\uline{Ranking:} Queries are typically sorted by their relevance, similar to a web search engine. Ranking is necessary not only for keyword search, but also for structured queries, when transitions to other data sources should be approximated.  

\uline{Heterogenity:} Answers will come from many sources and will differ in their used data model and schema. The Ranking has to manage heterogeneity, too.

\uline{Sources as answers:} In addition to base elements (e.g. documents or tuples), a DSSP should be able to provide sources, as well. This means that it returns links to locations where additional answers can be found.

\uline{Iterative queries:} Normally, the interaction with a dataspace can't be reduced to the process of posing  a sole query and getting an answer to it. Instead, a user is involved in an information finding task that requires a sequence of queries, each being a refinement or modification on the previous ones.

\uline{Reflection:} It is expected, that a DSSP reflects on the completeness of its coverage and the accuracy of its answers. 


\textbf{2. Dealing with challenges}

The first step to face these challenges is to build a formal model. Therefore, the authors propose five directives:

\uline{Challenge 3.1.}  The development of a formal model for analyzing the query answering in a dataspace. 

\uline{Sub-Challenge 3.2.} The development of intuitive semantics to answer a query taking into consideration a sequence of earlier posed queries. 

\uline{Sub-Challenge 3.3.} The development of a model for an information finding task which includes operations on lower levels. 

\uline{Sub-Challenge 3.4.} The development of algorithms sorting the data sources according to how likely they are to contain the answer. These algorithms should start from a keyword query and operate on a large collection of data sources.

\uline{Sub-Challenge 3.5.} The development of methods for ranking answers retrieved by multiply heterogeneous data sources.


\textbf{3. Query answering model and challenges}

\uline{Challenge 3.7.} The development of techniques to answer queries based on the following ideas or  
combinations of it:

- apply several approximate or uncertain mappings and compare the answers obtained by each.

- apply keyword search techniques to obtain some data or some constants that can be used in instantiating mappings.

- examine previous queries and answers obtained from data sources in the dataspace and try to infer mappings between the data sources. Whenever we have access to queries that span multiple data sources, try to infer from them how the sources are related (e.g., the join attributes should provide some hint of common domains).

- Develop a formal model  for approximating semantic mappings and for measuring the accuracy of answers obtained with them.

- Develop automatic best-effort methods for translating a query over one data set onto the other.

\textbf{{\large 4. Introspection}}

In chapter 4 introspection within a dataspace is analyzed. Introspection describes on this occasion the ability of a dataspace to observe assumptions and uncertainties and specifying their origin. In contrast to traditional databases introspection isn't a nice feature but a necessity. Introspection has to be possible over the following highly related parameters: Lineage, Uncertainty and Inconsistency. Thus, one speaks of LUI introspection in the context of dataspaces.

\textbf{4.1.1.Uncertain databases }

Uncertainty arises in applications for data management if the exact state of the (data) world is not known. The goal of a uncertain database is to represent a set of possible states the world can have. Usually, the states are referred to as possible worlds. Every possible world represents a complete valid state of the database. For declaring these states there were developed several formalisms \cite{FoundationOfDatabases1995, Barbara:1992:MPD:627288.627535, WorkingModelsForUncertainData, Grahne:1984:DSD:645912.671297, Lakshmanan:1997:PFP:261124.261131}. Examples for formalisms would be a-tuples, x-tuples or c-tables\cite{DBLP:reference/db/Grahne09a}.


\textbf{4.1.2. Inconsistency in databases}

The task of an inconsistency database is to handle situations where the database contains conflicting data. A common example would be the existence of two values of a salary of an employee whereby the values are obtained from different data sources. The essence for solving this problem is to consider all possible repairs. A repair is a minimal change resulting the database to a consistent state. As a rule, there are more one one possibility which is why the database owns several repairs to choose from. That's also the reason for the tight relationship between uncertainty and inconsistency as inconsistency can be interpreted as uncertainty over the knowledge, which of the conflicting value is the best solution.

\textbf{4.1.3. Modeling of data lineage}

The lineage of a tuple reports how the tuple was derived from a certain data set. There is a distinction to internal and external lineage. Internal lineage applies to tuples of a query result -- lineage specifies here how the tuple was derived within a database. External lineage relates to tuples inserted into a database, the lineage relates hereby to the external sources or processes by which the tuples were inserted. 

\textbf{4.1.4 LUI Introspection}

A DSSP should provide a uniform mechanism for modeling uncertainty, inconsistency and lineage. Thereby the following challenges arise:

\uline{Challenge 4.1.}  Develop a formalism for enabling the modeling of uncertainty, inconsistency and lineage.

\uline{Sub-Challenge 4.2.}  Develop a formalism which captures the uncertainty over general forms of inconsistency in databases.

As inconsistency results to a special type of uncertainty, the formalism for uncertainty should leverage this special structure. The formalism for uncertainty tells us only what the possible states of the world are and sometimes it assigns every possible world its corresponding possibility. But in many cases, it is the only way to resolve uncertainty and to get knowledge about data lineage and how and where the data was derived from.

Web search engines already unify uncertainty and lineage in a simple way. One of the main reasons why the authors want to unify lineage and uncertainty is to reason the relationship between external sources and their impact on answers. Thereby arises the following challenges:

\uline{Sub-Challenge 4.3.}  Develop a formalism which represents the external lineage and reasons it.

To combine uncertainty and lineage, there exists

\uline{Sub-Challenge 4.4.}  Develop a general technique for extending every kind of uncertainty and for investigating the representative and calculative advantages of this procedure. 

To achieve this, the object that should be assigned uncertainty, has to match to the object lineage is attributed to. 

\textbf{Uncertainty on Views}

There's a general problem with modeling uncertainty as the uncertainty formalism associate uncertainty with a single schematic construct: tuples in the case of x-tuples and attribute values in the case of a-tuples. So the chose of database schema and normalization limits the kinds of uncertainty to express. In the case of using views, the authors propose to link uncertainty with the view's tuples, hence:

\uline{Sub-Problem 4.5.} Develop formalisms where uncertainty can be attached to tuples in views and view uncertainty can be used to derive uncertainty of other tuples

\textbf{4.2 Finding the right answer}

This chapter address to what has to be done to determine the quality of a query answer (how good is a query?).

\uline{Sub-Challenge 4.6.} Define metrics for comparing the quality of query answers and answer sets over a dataspace, and find efficient techniques to process queries.

A limited version of this issue was already addressed with minimal repairs related to inconsistent databases. Here it will be tried to construct a consistent database as tight as possible on the base of the inconsistent one. For improving the results, it is necessary to do some preferences, which results in the following challenges:

\uline{Sub-Challenge 4.7.} Develop query-language extensions and their corresponding semantics that enable specifying preferences on answer sets along the dimensions of completeness and precision, certainty and inconsistency, lineage preferences and latency.

Along with the specification of preferences there are needed methods for reasoning query answer sets. This is essential for comparing answer sets. Query containment \cite{Chandra:1977:OIC:800105.803397} will be extended in the context to dataspaces. By which the following challenge submits to:

\uline{Sub-Challenge 4.8.} Define notions of query containment that take into consideration completeness and precision, uncertainty and inconsistency and lineage of answers, and efficient algorithms for computing containment.

The following issues stands in relation to section 4.1.:

\uline{Sub-Challenge 4.9.} Develop methods for efficient processing of queries over uncertain and inconsistent data that conserve the external and internal lineage of the answers. Study whether existing query processors can be leveraged for this goal.